<!DOCTYPE html>
<html>
  <head></head>
  <body>

<h1>Testing secure payment and username retrival from database</h1>
    
<p style="text-align: center;"></p>
<label>Enter and leave the payAccess key to unlock Observations 5-21:</label><input id="username" type="text" value="" placeholder="username" rows="1" cols="50" style='text-align: center; width: 400px;'>
<button id="submit_username" onclick="submit_username()" style="display:block">submit_username</button>
<br>
<div id="notification"></div>
<div id="error"></div>
<div id="response"></div>
<div id="verification" style="display:block"></div>



<!-- Insert library_to_run_GitHub_Actions.js CDN library HERE  -->
<script type="module" src="./index.js"></script>


<!-- Insert library_window_crypto_subtle.js CDN library HERE  -->
<!-- <script type="module" src="./index.js"></script> -->

<!-- --------------------------------------------------- -->
    
<script>

// ------------------------------------------------
  
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});
  
// ------------------------------------------------

async function submit_username() {

  RepoAobj = {};
  
  RepoAobj.repoOwner = "CodeSolutions2";
  RepoAobj.filename = "cb.txt";
  RepoAobj.repoA_name = "frontend_backend_message_passing_central_repository_v1"; // normally this would be a different repository
  RepoAobj.repoB_name = "frontend_backend_message_passing_central_repository_v1";
  RepoAobj.call_type = "insert_username";  // File database functions: insert_username, comparator_username_search
  RepoAobj.input_text = document.getElementById("username").value+"|"+RepoAobj.call_type; // these are values to be sent to the backend in one variable
  RepoAobj.foldername = "webappb";
  
  var output_file_path = RepoAobj.foldername+"/response";

  
  await string_to_object_key(RepoAobj);

  // No persistance version - basic version 0
  // RepoB does all processing: decrypt file_storage, add username to file_storage OR search for username in file_storage, encrypt file_storage, creates a file called response with [Present, Not Present] if it searches for username
  
  // RepoA webscrapes response file if it searches for username
  // await verify_usage(output_file_path);

  // Every time the user moves to a new locked observation, the workflows re-verifies.
}
    
// ------------------------------------------------

async function string_to_object_key(RepoAobj) {

	// RepoAobj.repoOwner, RepoAobj.repoA_name, RepoAobj.foldername, RepoAobj.filename, RepoAobj.input, RepoAobj.repoB_name, RepoAobj.repoOwner
	
	// n is the maximum salt length used

	var obj_env = await GET_text_from_file_wo_auth_GitHub_RESTAPI(".env", ".github", RepoAobj.repoB_name, RepoAobj.repoOwner);
	
	var obj_public = await GET_text_from_file_wo_auth_GitHub_RESTAPI(".public_window_crypto_subtle", ".github", RepoAobj.repoB_name, RepoAobj.repoOwner);

	var obj_private = await GET_text_from_file_wo_auth_GitHub_RESTAPI(".private_window_crypto_subtle", ".github", RepoAobj.repoB_name, RepoAobj.repoOwner);
	
	var obj = {env_text: obj_env.text.replace(/[\n\s]/g, ""), 
		   env_file_download_url: obj_env.file_download_url, 
		   env_sha: obj_env.sha, 
		   public_text: obj_public.text.replace(/[\n\s]/g, ""), 
		   public_file_download_url: obj_public.file_download_url, 
		   public_sha: obj_public.sha,
		   private_text: obj_private.text.replace(/[\n\s]/g, ""), 
		   private_file_download_url: obj_private.file_download_url, 
		   private_sha: obj_private.sha,
		   n: 1,
		   repoOwner: RepoAobj.repoOwner,
		   filename: RepoAobj.filename, 
		   foldername: RepoAobj.foldername, 
		   input_text: RepoAobj.input_text, 
		   repoB_name: RepoAobj.repoB_name,
	};

	Object.freeze(obj.env_text); // make the original value non-changeable
	Object.freeze(obj.public_text); // make the original value non-changeable
	Object.freeze(obj.private_text); // make the original value non-changeable
	
	await run_window_crypto_subtle_decryption_frontend(obj);
}

// ------------------------------------------------

async function run_window_crypto_subtle_decryption_frontend(obj) {
	
	// [1] Add obj_public, obj_private, and obj_temp to the general object (obj)
	// obj.public_text
	// obj.public_file_download_url
	// obj.public_sha
	obj.public_desired_path = obj.public_file_download_url.split('main/').pop();
	// console.log('obj.public_desired_path: ', obj.public_desired_path);

	// obj.private_text
	// obj.private_file_download_url
	// obj.private_sha
	obj.private_desired_path = obj.private_file_download_url.split('main/').pop();
	// console.log('obj.private_desired_path: ', obj.private_desired_path);
	
	// ------------------------------------------------

	// Step 0: convert the JSON Web key (Key_jwk_obj) to an object (Key_obj)
	obj.auth = obj.public_text; // Initialize value
	obj = await find_a_key_match(obj);
	obj.publicKey_obj = obj.Key_obj;
	delete obj.Key_obj;

	obj.auth = obj.private_text; // Initialize value
	obj = await find_a_key_match(obj);
	obj.privateKey_obj = obj.Key_obj;
	delete obj.Key_obj;
	
	// ------------------------------------------------

	// Step 1: decrypt the file_database
	var obj_filedatabase = await GET_text_from_file_wo_auth_GitHub_RESTAPI("file_database.txt", obj.foldername, obj.repoB_name, obj.repoOwner)
	console.log('obj_filedatabase: ', obj_filedatabase);
	
	obj.filedatabase_text = atob(obj_filedatabase.text);
	obj.filedatabase_file_download_url = obj_filedatabase.file_download_url; // this is a string
	obj.filedatabase_sha = obj_filedatabase.sha; // this is a string

	console.log('obj.filedatabase_text: ', obj.filedatabase_text);
	console.log('obj.filedatabase_text.length: ', obj.filedatabase_text.length);

	// ------------------------------------------------
	
  	delete obj.publicKey_obj;
	delete obj.auth;
	
	return obj;
}

// ------------------------------------------------
	
async function convert_arr_to_str(arr, sep) {
	return arr.map((val, ind) => { 
		if (ind == 0) {
			return sep+val+sep; 
		} else {
			return val+sep;
		}
	}).join('');
}

// ------------------------------------------------

async function comparator_search_for_a_username(decrypted_file_database, username) {
	
	let arr_db = decrypted_file_database.split('\n');
	console.log("arr_db:", arr_db);
	
	// Make usernames unique by adding | before and after each username
	const arr_db_uq_str = await convert_arr_to_str(arr_db, "|");
	console.log("arr_db_uq_str:", arr_db_uq_str);
	
	// Search for a unique username
  	let regex = new RegExp(`\\|${username}\\|`, 'g');
	console.log("regex: ", regex);
	
	// true=name is present in database, false=name is not present in database
	console.log("regex.test(arr_db_uq_str):", regex.test(arr_db_uq_str));
	
	if (regex.test(arr_db_uq_str) == true) {
		return 'Present';
	} else {
		return 'Not Present';
	}
}
	
// ------------------------------------------------

async function find_a_key_match(obj) {

	obj.status = 404; // Initialize value
		
	// [2] Loop over the number of possible values
	let i = 0;
	var x = Array.from({ length: (obj.n*2)+1 }, (_, ind) => ind);
	var x_rand = await rand_perm(x);
	
	// console.log('x: ', x);
	// console.log('x_rand: ', x_rand);
	
	while ((/^20/g).test(obj.status) == false && obj.auth != null && i < (obj.n*2)+1) {
		
		obj = await decode_desalt(obj,  x_rand[i])
			.then(async function(obj) {
				
				console.log('obj.auth: ', obj.auth.slice(0,5));
				try {
					// A process to determine if it is the correct key: it will throw an error if the key is incorrect
					// Step 0: convert the JSON Web key (Key_jwk_obj) to an object (Key_obj)
					if ((/encrypt/g).test(obj.auth) == true) {
						console.log('JWT public key');
						obj.Key_obj = await window.crypto.subtle.importKey("jwk", JSON.parse(obj.auth), {name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: {name: "SHA-256"} }, true, ["encrypt"]);
						obj.status = 200;
						
					} else if ((/decrypt/g).test(obj.auth) == true) {
						console.log('JWT private key');
						obj.Key_obj = await window.crypto.subtle.importKey("jwk", JSON.parse(obj.auth), {name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: {name: "SHA-256"} }, true, ["decrypt"]);
						obj.status = 200;
						
					} else {
						console.log('Github key');
						console.log('obj.file_download_url: ', obj.file_download_url);

						console.log('obj.put_message: ', obj.put_message);
						console.log('obj.input_text: ', obj.input_text);
						console.log('obj.desired_path: ', obj.desired_path);
						console.log('obj.sha: ', obj.sha);
						console.log('obj.repoB_name: ', obj.repoB_name);
						console.log('obj.repoOwner: ', obj.repoOwner);
						
						if (obj.file_download_url == "No_file_found") {
							// Option 0: create a new file
						  	obj.status = await PUT_create_a_file_RESTAPI(obj.auth, obj.put_message, obj.input_text, obj.foldername+"/"+obj.filename, obj.repoB_name, obj.repoOwner)
						 		.then(async function(out) { return out.status; })
			 			 		.catch(error => { console.log("error: ", error); });
				 		} else {
							// Option 1: modify an existing file
					 	 	obj.status = await PUT_add_to_a_file_RESTAPI(obj.auth, obj.put_message, obj.input_text, obj.desired_path, obj.sha, obj.repoB_name, obj.repoOwner)
						 		.then(async function(out) { return out.status; })
			 			 		.catch(error => { console.log("error: ", error); });
				 		}
					}
					
				} catch (error) {
					console.log('error: ', error);
					obj.status = 404; 
				}
				return obj;
			})
			.then(async function(obj) {
				console.log("obj.status:", obj.status);
				
				if ((/^20/g).test(obj.status) == true) {
					console.log("Match found");
					if ((/encrypt/g).test(obj.auth) == false && (/decrypt/g).test(obj.auth) == false) {
						obj.Key_obj = obj.auth;
					}
					delete obj.auth; // the variable is deleted to force it to stop the loop as quickly as possible, it will then throw an error for the while loop thus the while loop is called in a try catch to prevent errors.
				} else {
					if ((/encrypt/g).test(obj.auth) == true) {
						obj.auth = obj.public_text; // reinitialize value to keep the value obj.auth non-visible
					} else if ((/decrypt/g).test(obj.auth) == true) {
						obj.auth = obj.private_text; // reinitialize value to keep the value obj.auth non-visible
					} else {
						obj.auth = obj.env_text; // reinitialize value to keep the value obj.auth non-visible
					}
				}
				
				return obj;
			})
			.then(async function(obj) { await new Promise(r => setTimeout(r, 2000)); return obj; })
		
		// Advance while loop
		// console.log("loop i: ", i);
		// console.log("x_rand[i]: ", x_rand[i]);
		i += 1;	
	}
	return obj;
}

// ------------------------------------------------

async function verify_usage(output_file_path) {

  var text_out = "404: Not Found";
  var i = 0;
  while (text_out != "404: Not Found" && i < 15) {

      text_out = await GET_response(output_file_path)
        .then(async function (text_out) {
          if (text_out != "404: Not Found") {
            document.getElementById('verification').innerHTML = "OK";
          }
        })
        .then(async function (text_out) { await new Promise(r => setTimeout(r, 10000)); })
        .catch(error => {console.log("error: ", error)})
      i += 1;
      console.log("i: ", i);
  }
}

// ------------------------------------------------

async function GET_response(output_file_path) {
  return await fetch(`https://raw.githubusercontent.com/CodeSolutions2/frontend_backend_message_passing_central_repository_v1/main/${output_file_path}`)
      .then(res => res.text())
      .then(async function(result) {return result;})
      .catch(error => {console.log("error: ", error)})

}

// ------------------------------------------------

  
    
  </script>

  </body>
</html>
