<!DOCTYPE html>
<html>
  <head></head>
  <body>

<h1>Testing secure payment and username retrival from database</h1>
    
<p style="text-align: center;"></p>
<label>Enter and leave the payAccess key to unlock Observations 5-21:</label><input id="username" type="text" value="" placeholder="username" rows="1" cols="50" style='text-align: center; width: 400px;'>
<button id="submit_username" onclick="submit_username()" style="display:block">submit_username</button>
<br>
<div id="notification"></div>
<div id="error"></div>
<div id="response"></div>
<div id="verification" style="display:block"></div>



<!-- Insert library_to_run_GitHub_Actions.js CDN library HERE  -->
<script type="module" src="./index.js"></script>


<!-- Insert library_window_crypto_subtle.js CDN library HERE  -->
<!-- <script type="module" src="./index.js"></script> -->

<!-- --------------------------------------------------- -->
    
<script>

// ------------------------------------------------
  
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});
  
// ------------------------------------------------

async function submit_username() {

  RepoAobj = {};
  
  RepoAobj.repoOwner = "CodeSolutions2";
  RepoAobj.filename = "cb.txt";
  RepoAobj.repoA_name = "frontend_backend_message_passing_central_repository_v1"; // normally this would be a different repository
  RepoAobj.repoB_name = "frontend_backend_message_passing_central_repository_v1";
  RepoAobj.call_type = "insert_username";  // File database functions: insert_username, comparator_username_search
  RepoAobj.input = document.getElementById("username").value+"|"+RepoAobj.call_type;
  RepoAobj.foldername = "webappb";
  
  var output_file_path = RepoAobj.foldername+"/response";

  
  await string_to_object_key(RepoAobj);

  // No persistance version - basic version 0
  // RepoB does all processing: decrypt file_storage, add username to file_storage OR search for username in file_storage, encrypt file_storage, creates a file called response with [Present, Not Present] if it searches for username
  
  // RepoA webscrapes response file if it searches for username
  // await verify_usage(output_file_path);

  // Every time the user moves to a new locked observation, the workflows re-verifies.
}
    
// ------------------------------------------------

async function string_to_object_key(RepoAobj) {

	// RepoAobj.repoOwner, RepoAobj.repoA_name, RepoAobj.foldername, RepoAobj.filename, RepoAobj.input, RepoAobj.repoB_name, RepoAobj.repoOwner
	
	// n is the maximum salt length used
	
	var obj_public = await GET_text_from_file_wo_auth_GitHub_RESTAPI(".public_window_crypto_subtle", ".github", RepoAobj.repoB_name, RepoAobj.repoOwner);

	var obj_private = await GET_text_from_file_wo_auth_GitHub_RESTAPI(".private_window_crypto_subtle", ".github", RepoAobj.repoB_name, RepoAobj.repoOwner);
	
	var obj = {public_text: obj_public.text.replace(/[\n\s]/g, ""), 
		   public_file_download_url: obj_public.file_download_url, 
		   public_sha: obj_public.sha,
		   private_text: obj_private.text.replace(/[\n\s]/g, ""), 
		   private_file_download_url: obj_private.file_download_url, 
		   private_sha: obj_private.sha,
		   n: 1,
		   repoOwner: RepoAobj.repoOwner,
		   filename: RepoAobj.filename, 
		   foldername: RepoAobj.foldername, 
		   input_text: RepoAobj.input, 
		   repoB_name: RepoAobj.repoB_name};

	Object.freeze(obj.public_text); // make the original value non-changeable
	Object.freeze(obj.private_text); // make the original value non-changeable
	await run_window_crypto_subtle_decryption(obj);
	
}

// ------------------------------------------------

async function run_window_crypto_subtle_decryption(obj) {
	
	// Try each of the 'de-salted' authorization keys to identify the correct key: loop over a REST API request and identify which key succeeds
	// console.log('obj.repoB_name: ', obj.repoB_name);
	
	// [0] Determine if filename exists
	var obj_temp = await GET_fileDownloadUrl_and_sha(obj.filename, obj.foldername, obj.repoB_name, obj.repoOwner)

	// [1] Add obj_public, obj_private, and obj_temp to the general object (obj)
	// obj.public_text
	// obj.public_file_download_url
	// obj.public_sha
	obj.public_desired_path = obj.public_file_download_url.split('main/').pop();
	// console.log('obj.public_desired_path: ', obj.public_desired_path);

	// obj.private_text
	// obj.private_file_download_url
	// obj.private_sha
	obj.private_desired_path = obj.private_file_download_url.split('main/').pop();
	// console.log('obj.private_desired_path: ', obj.private_desired_path);
	
	obj.temp_file_download_url = obj_temp.file_download_url[0]; // this is a string
	obj.temp_desired_path = obj.temp_file_download_url.split('main/').pop();
	obj.temp_sha = obj_temp.sha_arr[0]; // this is a string



	
	obj.auth = obj.public_text; // Initialize value
	obj.status = 404; // Initialize value
		
	// [2] Loop over the number of possible values
	let i = 0;
	var x = Array.from({ length: (obj.n*2)+1 }, (_, ind) => ind);
	var x_rand = await rand_perm(x);
	
	// console.log('x: ', x);
	// console.log('x_rand: ', x_rand);

	// let privateKey_obj = await window.crypto.subtle.importKey("jwk", privateKey_jwk_obj, {name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: {name: "SHA-256"} }, true, ["deriveKey", "deriveBits"]);


	
	while ((/^20/g).test(obj.status) == false && obj.auth != null && i < (obj.n*2)+1) {
		
		obj = await decode_desalt(obj,  x_rand[i])
			.then(async function(obj) {

				try {
					// A process to determine if it is the correct key
					// Step 1: convert the JSON Web key (privateKey_jwk_obj) to an object (publicKey_obj)
					let publicKey_obj = await window.crypto.subtle.importKey("jwk", obj.auth, {name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: {name: "SHA-256"} }, true, []);
					console.log('publicKey_obj: ', publicKey_obj);

					// figure out what it outputs for error and what it outputs for correct()
					var var_type = typeof publicKey_obj;
					console.log('var_type: ', var_type);
					obj.status = 200;
				} catch (error) {
					obj.status = 404; 
				}
				
				return obj;
			})
			.then(async function(obj) {
				console.log("obj.status:", obj.status);
				
				if ((/^20/g).test(obj.status) == true) {
					console.log("Match found");
					delete obj.auth; // the variable is deleted to force it to stop the loop as quickly as possible, it will then throw an error for the while loop thus the while loop is called in a try catch to prevent errors.
				} else {
					obj.auth = obj.public_text; // reinitialize value to keep the value obj.auth non-visible
				}
				
				return obj;
			})
			.then(async function(obj) { await new Promise(r => setTimeout(r, 2000)); return obj; })
		
		// Advance while loop
		// console.log("loop i: ", i);
		// console.log("x_rand[i]: ", x_rand[i]);
		i += 1;	
	}
		
}

// ------------------------------------------------


// ------------------------------------------------


// ------------------------------------------------

async function verify_usage(output_file_path) {

  var text_out = "404: Not Found";
  var i = 0;
  while (text_out != "404: Not Found" && i < 15) {

      text_out = await GET_response(output_file_path)
        .then(async function (text_out) {
          if (text_out != "404: Not Found") {
            document.getElementById('verification').innerHTML = "OK";
          }
        })
        .then(async function (text_out) { await new Promise(r => setTimeout(r, 10000)); })
        .catch(error => {console.log("error: ", error)})
      i += 1;
      console.log("i: ", i);
  }
}

// ------------------------------------------------

async function GET_response(output_file_path) {
  return await fetch(`https://raw.githubusercontent.com/CodeSolutions2/frontend_backend_message_passing_central_repository_v1/main/${output_file_path}`)
      .then(res => res.text())
      .then(async function(result) {return result;})
      .catch(error => {console.log("error: ", error)})

}

// ------------------------------------------------

  
    
  </script>

  </body>
</html>
