name: REPOB processes REPOA data

on:
  push:
    branches:
      - main
    paths:
      - 'webappb/**.txt'
    
jobs:
  dispatch:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      
    steps:
      - name: Get repository files (equivalent to git pull)
        uses: actions/checkout@v2


      - name: Decrypt the file
        uses: actions/github-script@v4
        env:
          USERNAME: "$(cat webappb/cb.txt | cut -d '|' -f 1)"
          CALL_TYPE: "$(cat webappb/cb.txt | cut -d '|' -f 2)"
          FILE_DATABASE: "$(cat webappb/file_database.csv)"
          PUBLIC_KEY_RSA: '${{ secrets.PUBLIC_KEY_RSA }}'
          PRIVATE_KEY_RSA: '${{ secrets.PRIVATE_KEY_RSA }}'
        with:
          github-token: ${{ secrets.REPOB_V1 }}
          script: |

            
            // Get username from cb.txt
            const { USERNAME } = process.env
            let username = `${USERNAME}`;

            // --------------------------------

            // Get call_type from cb.txt
            const { CALL_TYPE } = process.env
            let call_type = `${CALL_TYPE}`;

            // --------------------------------
            
            // Get encrypted data from file_database.csv
            const { FILE_DATABASE } = process.env
            let file_database = `${FILE_DATABASE}`;

            // --------------------------------
            
            // Decrypt data from file_database.csv

            // Step 0: get keys
            const { PUBLIC_KEY_RSA } = process.env
            let publicKey_jwk_str = `${PUBLIC_KEY_RSA}`;
            let publicKey_jwk_obj = JSON.parse(publicKey_jwk_str);

            const { PRIVATE_KEY_RSA } = process.env
            let privateKey_jwk_str = `${PRIVATE_KEY_RSA}`;
            let privateKey_jwk_obj = JSON.parse(privateKey_jwk_str);

            // --------------------------------
            
            // Step 1: convert the JSON Web key (privateKey_jwk_obj) to an object (publicKey_obj)
            let publicKey_obj = await window.crypto.subtle.importKey("jwk", publicKey_jwk_obj, {name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: {name: "SHA-256"} }, true, []);
            
            let privateKey_obj = await window.crypto.subtle.importKey("jwk", privateKey_jwk_obj, {name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: {name: "SHA-256"} }, true, ["deriveKey", "deriveBits"]);

            // --------------------------------
            
            // Step 2: decrypt the file_database
            // Convert string into arraybuffer
            const uint8Array = new TextEncoder().encode(file_database);
            const arrayBuffer = uint8Array.buffer;
            
            // Decode with respect to RSA privateKey
            let data_decoded_String = await window.crypto.subtle.decrypt({name: "RSA-OAEP"}, privateKey_obj, arrayBuffer);
            
            var decrypted_file_database = new TextDecoder().decode(data_decoded_String);
            console.log("decrypted_file_database:", decrypted_file_database);

            // --------------------------------

            let result = await comparator_search_for_a_username(decrypted_file_database, username);

            // --------------------------------
            
            if (call_type == 'add_username') {
              // --------------------------------
              // Procedure to add a name 
              // --------------------------------
              if (result == 'Not Present') {
                
                // Add username to file_database.csv
                let data_encoded0_String = await insert_username(decrypted_file_database, username, publicKey_obj);
                
                // --------------------------------
    
                // Save encrypted data back to file_database.csv
                const fs = require('fs');
                fs.writeFileSync('webappb/file_database.csv', data_encoded0_String);
                fs.writeFileSync('webappb/response', "Username added");
                
              } else {
                const fs = require('fs');
                fs.writeFileSync('webappb/response', "Username is Present, select another username");
              }
  
              // --------------------------------
              } else {
                // --------------------------------
                // Procedure to search for a username in file_database
                // --------------------------------
                const fs = require('fs');
                fs.writeFileSync('webappb/response', result); // Present, Not Present
              }

              // --------------------------------
              
              async function comparator_search_for_a_username(decrypted_file_database, username) {
                let arr_db = decrypted_file_database.split('\n');
                console.log("arr_db:", arr_db);
                
                // Make usernames unique by adding | before and after each username
                let arr_db_uq_str = arr_db.map((val, ind) => { 
                  if (ind == 0) {
                    return "|"+val+"|"; 
                  } else {
                    return val+"|";
                  }
                }).join('');
                console.log("arr_db_uq_str:", arr_db_uq_str);
  
                // Search for a unique username
                let regex = new RegExp(`|${username}|`, 'g');

                // true=name is present in database, false=name is not present in database
                if (regex.test(arr_db_uq_str) == true) {
                  return 'Present';
                } else {
                  return 'Not Present';
                }
              }

              // --------------------------------
              
              async function insert_username(decrypted_file_database, username, publicKey_obj) {
                // Add new content to file
                str_text = decrypted_file_database + "\n" + username;  // with RSA encryption
                console.log('str_text:', str_text); 
    
                // Convert string raw_text to an arrayBuffer
                // Encode arrayBuffer with RSA publicKey (so encoded data is only visible to the public, to protect user's data)
                const textBuffer = new TextEncoder().encode(str_text);
                console.log('textBuffer:', textBuffer);
    
                // --------------------------------
                
                // Use the public key object to re-encrypt the string data, it returns an new arrayBuffer
                let data_encoded_arrayBuffer = await window.crypto.subtle.encrypt({name: "RSA-OAEP"}, publicKey_obj, textBuffer);
    
                // --------------------------------
                
                // Encrypt data : Convert the encoded/encrypted arrayBuffer to a string, such that it is saved in the public file
    
                // Way 1
                const data_encoded0_String = String.fromCharCode(...(new Uint8Array(data_encoded_arrayBuffer)));
                console.log("data_encoded0_String:", data_encoded0_String);
    
                // Way 2
                // Convert it to Uint8Array (a standard array format)
                const uint8Array = new Uint8Array(data_encoded_arrayBuffer);
                console.log('uint8Array:', uint8Array); 
                const textDecoder = new TextDecoder('utf-8');
                const data_encoded1_String = textDecoder.decode(uint8Array);
                console.log("data_encoded1_String:", data_encoded1_String);

                return data_encoded0_String;
              }

              // --------------------------------


      - name: Commit and push changes back to repository
        run:  git config --global user.email "j622amilah@gmail.com"; git config --global user.name "CodeSolutions2"; git pull origin main; git checkout main; git branch --set-upstream-to origin/main; git merge main --ff-only; git add -A; git diff-index --quiet HEAD || git commit -m "add files" --allow-empty; git push https://${{ secrets.REPOB_V1 }}@github.com/CodeSolutions2/frontend_backend_message_passing_central_repository_v1.git
